{"version":3,"sources":["../../src/command/command-registry.ts"],"names":["CommandRegistry","injectable"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAUaA,0BAAN,qBAAkD,CAAA;AAAA,EAAlD,WAAA,GAAA;AAKL;AAAA;AAAA;AAAA;AAAA,IAAQ,IAAA,CAAA,QAAA,uBAAsC,GAAI,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ3C,IAAI,OAAyB,EAAA;AAClC,IAAM,MAAA,IAAA,GAAO,QAAQ,OAAQ,EAAA;AAE7B,IAAA,IAAI,IAAK,CAAA,QAAA,CAAS,GAAI,CAAA,IAAI,CAAG,EAAA;AAC3B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAY,SAAA,EAAA,IAAI,CAAmB,iBAAA,CAAA,CAAA;AAAA;AAGrD,IAAK,IAAA,CAAA,QAAA,CAAS,GAAI,CAAA,IAAA,EAAM,OAAO,CAAA;AAAA;AACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,IAAI,IAAoC,EAAA;AAC7C,IAAO,OAAA,IAAA,CAAK,QAAS,CAAA,GAAA,CAAI,IAAI,CAAA;AAAA;AAC/B;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,MAAqB,GAAA;AAC1B,IAAA,OAAO,KAAM,CAAA,IAAA,CAAK,IAAK,CAAA,QAAA,CAAS,QAAQ,CAAA;AAAA;AAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,IAAI,IAAuB,EAAA;AAChC,IAAO,OAAA,IAAA,CAAK,QAAS,CAAA,GAAA,CAAI,IAAI,CAAA;AAAA;AAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,OAAO,IAAuB,EAAA;AACnC,IAAO,OAAA,IAAA,CAAK,QAAS,CAAA,MAAA,CAAO,IAAI,CAAA;AAAA;AAClC;AAAA;AAAA;AAAA,EAKO,KAAc,GAAA;AACnB,IAAA,IAAA,CAAK,SAAS,KAAM,EAAA;AAAA;AAExB;AApEaA,uBAAN,GAAA,eAAA,CAAA;AAAA,EADNC,oBAAW;AAAA,CACC,EAAAD,uBAAA,CAAA","file":"command-registry.js","sourcesContent":["import { injectable } from 'inversify'\nimport type { ICommand } from '@pixielity/ts-types'\nimport type { ICommandRegistry } from '@pixielity/ts-types'\n\n/**\n * Registry for console commands\n *\n * Stores and manages all registered commands.\n */\n@injectable()\nexport class CommandRegistry implements ICommandRegistry {\n  /**\n   * Map of command names to command instances\n   * @private\n   */\n  private commands: Map<string, ICommand> = new Map()\n\n  /**\n   * Adds a command to the registry\n   *\n   * @param {ICommand} command - The command to add\n   * @throws {Error} If a command with the same name already exists\n   */\n  public add(command: ICommand): void {\n    const name = command.getName()\n\n    if (this.commands.has(name)) {\n      throw new Error(`Command \"${name}\" already exists.`)\n    }\n\n    this.commands.set(name, command)\n  }\n\n  /**\n   * Gets a command by name\n   *\n   * @param {string} name - The name of the command\n   * @returns {ICommand | undefined} The command or undefined if not found\n   */\n  public get(name: string): ICommand | undefined {\n    return this.commands.get(name)\n  }\n\n  /**\n   * Gets all registered commands\n   *\n   * @returns {ICommand[]} Array of all registered commands\n   */\n  public getAll(): ICommand[] {\n    return Array.from(this.commands.values())\n  }\n\n  /**\n   * Checks if a command exists\n   *\n   * @param {string} name - The name of the command\n   * @returns {boolean} True if the command exists, false otherwise\n   */\n  public has(name: string): boolean {\n    return this.commands.has(name)\n  }\n\n  /**\n   * Removes a command from the registry\n   *\n   * @param {string} name - The name of the command\n   * @returns {boolean} True if the command was removed, false otherwise\n   */\n  public remove(name: string): boolean {\n    return this.commands.delete(name)\n  }\n\n  /**\n   * Clears all commands from the registry\n   */\n  public clear(): void {\n    this.commands.clear()\n  }\n}\n"]}