{"version":3,"sources":["../src/decorators/argument.decorator.ts","../src/decorators/option.decorator.ts","../src/di/container.ts","../src/decorators/command.decorator.ts","../src/output/output.ts","../src/application.ts"],"names":["chalk","injectable"],"mappings":"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","file":"application.mjs","sourcesContent":["import \"reflect-metadata\"\n\n/**\n * Metadata key for arguments\n */\nexport const ARGUMENT_METADATA_KEY = Symbol(\"argument\")\n\n/**\n * Argument options interface\n */\nexport interface ArgumentOptions {\n  /**\n   * The name of the argument\n   */\n  name: string\n\n  /**\n   * The description of the argument\n   */\n  description?: string\n\n  /**\n   * The default value of the argument\n   */\n  defaultValue?: any\n\n  /**\n   * Whether the argument is required\n   */\n  required?: boolean\n\n  /**\n   * Whether the argument is an array (variadic)\n   */\n  isArray?: boolean\n}\n\n/**\n * Argument decorator\n *\n * Defines a command argument\n *\n * @param {ArgumentOptions} options - The argument options\n * @returns {PropertyDecorator} The property decorator\n */\nexport function Argument(options: ArgumentOptions): PropertyDecorator {\n  return (target: Object, propertyKey: string | symbol) => {\n    // Format the argument name for Commander\n    // If it's required, don't add brackets\n    // If it's an array, add ellipsis\n    let name = options.name\n    if (!options.required) {\n      name = `[${name}]`\n    } else {\n      name = `<${name}>`\n    }\n\n    if (options.isArray) {\n      name = `${name}...`\n    }\n\n    const metadata = {\n      name,\n      description: options.description || \"\",\n      defaultValue: options.defaultValue,\n      propertyKey,\n    }\n\n    // Get existing metadata or initialize empty array\n    const existingMetadata = Reflect.getMetadata(ARGUMENT_METADATA_KEY, target.constructor) || []\n\n    // Add new metadata\n    existingMetadata.push(metadata)\n\n    // Update metadata\n    Reflect.defineMetadata(ARGUMENT_METADATA_KEY, existingMetadata, target.constructor)\n  }\n}\n","import \"reflect-metadata\"\n\n/**\n * Metadata key for options\n */\nexport const OPTION_METADATA_KEY = Symbol(\"option\")\n\n/**\n * Option options interface\n */\nexport interface OptionOptions {\n  /**\n   * The flags for the option (e.g., \"-n, --name\")\n   */\n  flags: string\n\n  /**\n   * The description of the option\n   */\n  description?: string\n\n  /**\n   * The default value of the option\n   */\n  defaultValue?: any\n}\n\n/**\n * Option decorator\n *\n * Defines a command option\n *\n * @param {OptionOptions} options - The option options\n * @returns {PropertyDecorator} The property decorator\n */\nexport function Option(options: OptionOptions): PropertyDecorator {\n  return (target: Object, propertyKey: string | symbol) => {\n    const metadata = {\n      flags: options.flags,\n      description: options.description || \"\",\n      defaultValue: options.defaultValue,\n      propertyKey,\n    }\n\n    // Get existing metadata or initialize empty array\n    const existingMetadata = Reflect.getMetadata(OPTION_METADATA_KEY, target.constructor) || []\n\n    // Add new metadata\n    existingMetadata.push(metadata)\n\n    // Update metadata\n    Reflect.defineMetadata(OPTION_METADATA_KEY, existingMetadata, target.constructor)\n  }\n}\n","import { Container } from \"inversify\"\nimport \"reflect-metadata\"\n\n/**\n * The global Inversify container instance\n */\nconst container = new Container({\n  defaultScope: \"Singleton\",\n})\n\nexport { container }\n","import 'reflect-metadata'\nimport { injectable } from 'inversify'\nimport { ICommand, ICommandOptions } from '@pixielity/ts-types'\n\nimport { container } from '../di/container'\n\n/**\n * Metadata key for command\n */\nexport const COMMAND_METADATA_KEY = Symbol('command')\n\n/**\n * Command decorator\n *\n * Marks a class as a console command and registers it with the container\n *\n * @param {CommandOptions} options - The command options\n * @returns {ClassDecorator} The class decorator\n */\nexport function Command(options: ICommandOptions): ClassDecorator {\n  return (target: Function): void => {\n    // Set default values for options\n    const commandOptions = {\n      ...options,\n      hidden: options.hidden ?? false,\n      injectable: options.injectable ?? true,\n      description: options.description || '',\n      shortcuts: options.shortcuts || [],\n    }\n\n    // Store command metadata with defaults applied\n    Reflect.defineMetadata(COMMAND_METADATA_KEY, commandOptions, target)\n\n    // Make the class injectable if not explicitly disabled\n    if (commandOptions.injectable) {\n      injectable()(target)\n\n      // Register the command with the container\n      // We use a multi-injection approach for commands\n      try {\n        container\n          .bind(ICommand.$)\n          .to(target as any)\n          .inSingletonScope()\n      } catch (error) {\n        // If the binding already exists, we can ignore the error\n        // This can happen during hot reloading\n      }\n    }\n  }\n}\n","import chalk from \"chalk\"\nimport type { IOutput } from \"@pixielity/ts-types\"\n\n/**\n * Implementation of the IOutput interface\n *\n * Provides methods for writing to the console with formatting using chalk.\n */\nexport class Output implements IOutput {\n  /**\n   * Writes a message to the output\n   *\n   * @param {string} message - The message to write\n   */\n  public write(message: string): void {\n    process.stdout.write(message)\n  }\n\n  /**\n   * Writes a message to the output followed by a newline\n   *\n   * @param {string} message - The message to write\n   */\n  public writeln(message: string): void {\n    console.log(message)\n  }\n\n  /**\n   * Writes an error message to the output\n   *\n   * @param {string} message - The error message to write\n   */\n  public error(message: string): void {\n    console.error(chalk.bold.red(\"ERROR\") + \": \" + message)\n  }\n\n  /**\n   * Writes a success message to the output\n   *\n   * @param {string} message - The success message to write\n   */\n  public success(message: string): void {\n    console.log(chalk.bold.green(\"SUCCESS\") + \": \" + message)\n  }\n\n  /**\n   * Writes an info message to the output\n   *\n   * @param {string} message - The info message to write\n   */\n  public info(message: string): void {\n    console.log(chalk.bold.blue(\"INFO\") + \": \" + message)\n  }\n\n  /**\n   * Writes a warning message to the output\n   *\n   * @param {string} message - The warning message to write\n   */\n  public warning(message: string): void {\n    console.log(chalk.bold.yellow(\"WARNING\") + \": \" + message)\n  }\n\n  /**\n   * Writes a comment message to the output\n   *\n   * @param {string} message - The comment message to write\n   */\n  public comment(message: string): void {\n    console.log(chalk.gray(\"// \" + message))\n  }\n}\n","import { Command } from 'commander'\nimport chalk from 'chalk'\nimport { injectable } from 'inversify'\nimport 'reflect-metadata'\nimport type { ICommandCollector, ICommandRegistry } from '@pixielity/ts-types'\nimport type { ICommand } from '@pixielity/ts-types'\nimport type { IConsoleApplication } from '@pixielity/ts-types'\nimport { ARGUMENT_METADATA_KEY } from './decorators/argument.decorator'\nimport { OPTION_METADATA_KEY } from './decorators/option.decorator'\nimport { COMMAND_METADATA_KEY } from './decorators/command.decorator'\nimport { Output } from './output/output'\n\n/**\n * Console Application class\n *\n * Manages the console commands and their execution using Commander.js.\n */\n@injectable()\nexport class Application implements IConsoleApplication {\n  /**\n   * The name of the application\n   * @private\n   */\n  private name: string\n\n  /**\n   * The version of the application\n   * @private\n   */\n  private version: string\n\n  /**\n   * The command registry that stores all registered commands\n   * @private\n   */\n  private commandRegistry: ICommandRegistry\n\n  /**\n   * The command collector for discovering commands\n   * @private\n   */\n  private commandCollector: ICommandCollector\n\n  /**\n   * The Commander.js program instance\n   * @private\n   */\n  private program: Command\n\n  /**\n   * Creates a new Console Application instance\n   *\n   * @param {ICommandRegistry} commandRegistry - The command registry\n   * @param {ICommandCollector} commandCollector - The command collector\n   * @param {ICommand[]} commands - The commands to register\n   * @param {string} name - The name of the application\n   * @param {string} version - The version of the application\n   */\n  constructor(\n    commandRegistry: ICommandRegistry,\n    commandCollector: ICommandCollector,\n    commands: ICommand[] = [],\n    name = 'Next.js Console',\n    version = '1.0.0',\n  ) {\n    this.name = name\n    this.version = version\n    this.commandRegistry = commandRegistry\n    this.commandCollector = commandCollector\n\n    // Initialize Commander program\n    this.program = new Command()\n      .name(this.name)\n      .version(this.version)\n      .description(`${this.name} - A Laravel/Symfony-inspired console for Next.js`)\n      .helpOption('-h, --help', 'Display help for command')\n      .addHelpCommand('help [command]', 'Display help for command')\n\n    // Add global options (shortcuts)\n    this.addGlobalOptions()\n\n    // Register commands\n    if (commands.length > 0) {\n      this.registerCommands(commands)\n    }\n  }\n\n  /**\n   * Add global options/shortcuts to the application\n   *\n   * @private\n   */\n  private addGlobalOptions(): void {\n    this.program\n      .option('-l, --list', 'List all available commands')\n      .option('-v, --version', 'Display this application version')\n      .option('-g, --greet [name]', 'Greet the user')\n      .option('-d, --demo [feature]', 'Run the demo with optional feature')\n      .option('-m, --make <name>', 'Create a new command')\n  }\n\n  /**\n   * Handle global options/shortcuts\n   *\n   * @param {any} options - The parsed options\n   * @returns {Promise<boolean>} True if an option was handled, false otherwise\n   * @private\n   */\n  private async handleGlobalOptions(options: any): Promise<boolean> {\n    if (options.list) {\n      // Run the list command\n      const listCommand = this.commandRegistry.get('list')\n      if (listCommand) {\n        listCommand.setOutput(new Output())\n        await listCommand.execute()\n        return true\n      }\n    }\n\n    if (options.greet !== undefined) {\n      // Run the greet command\n      const greetCommand = this.commandRegistry.get('greet')\n      if (greetCommand) {\n        greetCommand.setOutput(new Output())\n        if (typeof options.greet === 'string') {\n          greetCommand.setArguments([options.greet])\n        }\n        await greetCommand.execute()\n        return true\n      }\n    }\n\n    if (options.demo !== undefined) {\n      // Run the demo command\n      const demoCommand = this.commandRegistry.get('demo')\n      if (demoCommand) {\n        demoCommand.setOutput(new Output())\n        if (typeof options.demo === 'string') {\n          demoCommand.setOptions({ feature: options.demo })\n        }\n        await demoCommand.execute()\n        return true\n      }\n    }\n\n    if (options.make) {\n      // Run the make:command command\n      const makeCommand = this.commandRegistry.get('make:command')\n      if (makeCommand) {\n        makeCommand.setOutput(new Output())\n        makeCommand.setArguments([options.make])\n        await makeCommand.execute()\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Gets the name of the application\n   *\n   * @returns {string} The application name\n   */\n  public getName(): string {\n    return this.name\n  }\n\n  /**\n   * Sets the name of the application\n   *\n   * @param {string} name - The new application name\n   * @returns {Application} The application instance for chaining\n   */\n  public setName(name: string): Application {\n    this.name = name\n    this.program.name(name)\n    return this\n  }\n\n  /**\n   * Gets the version of the application\n   *\n   * @returns {string} The application version\n   */\n  public getVersion(): string {\n    return this.version\n  }\n\n  /**\n   * Sets the version of the application\n   *\n   * @param {string} version - The new application version\n   * @returns {Application} The application instance for chaining\n   */\n  public setVersion(version: string): Application {\n    this.version = version\n    this.program.version(version)\n    return this\n  }\n\n  /**\n   * Gets all registered commands\n   *\n   * @returns {ICommand[]} Array of all registered commands\n   */\n  public getCommands(): ICommand[] {\n    return this.commandRegistry.getAll()\n  }\n\n  /**\n   * Sets the commands for the application\n   * This will clear existing commands and register the new ones\n   *\n   * @param {ICommand[]} commands - The commands to register\n   * @returns {Application} The application instance for chaining\n   */\n  public setCommands(commands: ICommand[]): Application {\n    // Clear existing commands\n    this.commandRegistry.clear()\n\n    // Re-initialize the program to clear Commander commands\n    this.program = new Command()\n      .name(this.name)\n      .version(this.version)\n      .description(`${this.name} - A Laravel/Symfony-inspired console for Next.js`)\n      .helpOption('-h, --help', 'Display help for command')\n      .addHelpCommand('help [command]', 'Display help for command')\n\n    // Add global options\n    this.addGlobalOptions()\n\n    // Register the new commands\n    this.registerCommands(commands)\n\n    return this\n  }\n\n  /**\n   * Gets the command registry\n   *\n   * @returns {ICommandRegistry} The command registry\n   */\n  public getCommandRegistry(): ICommandRegistry {\n    return this.commandRegistry\n  }\n\n  /**\n   * Gets the command collector\n   *\n   * @returns {ICommandCollector} The command collector\n   */\n  public getCommandCollector(): ICommandCollector {\n    return this.commandCollector\n  }\n\n  /**\n   * Registers a command with the application\n   *\n   * @param {ICommand} command - The command to register\n   * @returns {Application} - The application instance for chaining\n   */\n  public register(command: ICommand): Application {\n    this.commandRegistry.add(command)\n\n    // Register with Commander\n    this.registerWithCommander(command)\n\n    return this\n  }\n\n  /**\n   * Registers multiple commands with the application\n   *\n   * @param {ICommand[]} commands - The commands to register\n   * @returns {Application} - The application instance for chaining\n   */\n  public registerCommands(commands: ICommand[]): Application {\n    commands.forEach((command) => this.register(command))\n    return this\n  }\n\n  /**\n   * Discovers and registers commands from a directory\n   *\n   * @param {string} directory - The directory to scan for commands\n   * @param {string} pattern - The glob pattern to match command files\n   * @returns {Promise<Application>} - The application instance for chaining\n   */\n  public async discoverCommands(\n    directory: string,\n    pattern = '**/*-command.{ts,js}',\n  ): Promise<Application> {\n    const commands = await this.commandCollector.discoverCommands(directory, pattern)\n    this.registerCommands(commands)\n    return this\n  }\n\n  /**\n   * Registers a command with Commander.js\n   *\n   * @param {ICommand} command - The command to register\n   * @private\n   */\n  private registerWithCommander(command: ICommand): void {\n    // Get command metadata if available\n    const metadata = Reflect.getMetadata(COMMAND_METADATA_KEY, command.constructor) || {}\n\n    // Skip hidden commands\n    if (metadata.hidden) {\n      return\n    }\n\n    const commanderCommand = new Command(command.getName())\n      .description(command.getDescription())\n      .action(async (...args) => {\n        try {\n          // Extract options from the last argument (Commander passes options as last arg)\n          const options = args.pop() || {}\n\n          // Set output\n          command.setOutput(new Output())\n\n          // Set arguments and options\n          command.setArguments(args)\n          command.setOptions(options)\n\n          // Run before execute hook if it exists\n          if (command.beforeExecute) {\n            const shouldContinue = await command.beforeExecute()\n            if (!shouldContinue) {\n              return\n            }\n          }\n\n          // Execute the command\n          const exitCode = await command.execute()\n\n          // Run after execute hook if it exists\n          if (command.afterExecute) {\n            await command.afterExecute(exitCode)\n          }\n\n          if (exitCode !== 0 && exitCode !== undefined) {\n            process.exit(exitCode)\n          }\n        } catch (error) {\n          console.error(\n            chalk.red(`Error: ${error instanceof Error ? error.message : String(error)}`),\n          )\n          process.exit(1)\n        }\n      })\n\n    // Add aliases if available\n    if (metadata.aliases && Array.isArray(metadata.aliases)) {\n      commanderCommand.aliases(metadata.aliases)\n    }\n\n    // Add command to the program\n    this.program.addCommand(commanderCommand)\n\n    // Process command metadata if available (from decorators)\n    this.processCommandMetadata(command, commanderCommand)\n  }\n\n  /**\n   * Processes command metadata from decorators\n   *\n   * @param {ICommand} command - The command instance\n   * @param {Command} commanderCommand - The Commander.js command\n   * @private\n   */\n  private processCommandMetadata(command: ICommand, commanderCommand: Command): void {\n    const constructor = command.constructor\n\n    // Process arguments\n    const argumentsMetadata = Reflect.getMetadata(ARGUMENT_METADATA_KEY, constructor) || []\n    argumentsMetadata.forEach((metadata: any) => {\n      commanderCommand.argument(metadata.name, metadata.description, metadata.defaultValue)\n    })\n\n    // Process options\n    const optionsMetadata = Reflect.getMetadata(OPTION_METADATA_KEY, constructor) || []\n    optionsMetadata.forEach((metadata: any) => {\n      commanderCommand.option(metadata.flags, metadata.description, metadata.defaultValue)\n    })\n  }\n\n  /**\n   * Runs the application with the given arguments\n   *\n   * @param {string[]} argv - The command line arguments\n   * @returns {Promise<void>}\n   */\n  public async run(argv: string[] = process.argv): Promise<void> {\n    try {\n      // Parse options without executing a command\n      this.program.allowUnknownOption(true)\n      const operands = this.program.parseOptions(argv.slice(2)).operands\n      const options = this.program.opts()\n\n      // Handle global options first\n      const optionsHandled = await this.handleGlobalOptions(options)\n\n      if (optionsHandled) {\n        return\n      }\n\n      // If no global options were handled, parse normally\n      await this.program.parseAsync(argv)\n    } catch (error) {\n      console.error(\n        chalk.red(`Fatal error: ${error instanceof Error ? error.message : String(error)}`),\n      )\n      process.exit(1)\n    }\n  }\n}\n"]}