{"version":3,"sources":["../../src/output/output.ts","../../src/scheduler/scheduler.ts"],"names":["chalk","CommandScheduler","injectable","inject","ICommandRegistry"],"mappings":"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","file":"scheduler.js","sourcesContent":["import chalk from 'chalk'\nimport type { IOutput } from '@pixielity/ts-types'\n\n/**\n * Implementation of the IOutput interface\n *\n * Provides methods for writing to the console with formatting using chalk.\n */\nexport class Output implements IOutput {\n  /**\n   * Writes a message to the output\n   *\n   * @param {string} message - The message to write\n   */\n  public write(message: string): void {\n    process.stdout.write(message)\n  }\n\n  /**\n   * Writes a message to the output followed by a newline\n   *\n   * @param {string} message - The message to write\n   */\n  public writeln(message: string): void {\n    console.log(message)\n  }\n\n  /**\n   * Writes an error message to the output\n   *\n   * @param {string} message - The error message to write\n   */\n  public error(message: string): void {\n    console.error(chalk.bold.red('ERROR') + ': ' + message)\n  }\n\n  /**\n   * Writes a success message to the output\n   *\n   * @param {string} message - The success message to write\n   */\n  public success(message: string): void {\n    console.log(chalk.bold.green('SUCCESS') + ': ' + message)\n  }\n\n  /**\n   * Writes an info message to the output\n   *\n   * @param {string} message - The info message to write\n   */\n  public info(message: string): void {\n    console.log(chalk.bold.blue('INFO') + ': ' + message)\n  }\n\n  /**\n   * Writes a warning message to the output\n   *\n   * @param {string} message - The warning message to write\n   */\n  public warning(message: string): void {\n    console.log(chalk.bold.yellow('WARNING') + ': ' + message)\n  }\n\n  /**\n   * Writes a comment message to the output\n   *\n   * @param {string} message - The comment message to write\n   */\n  public comment(message: string): void {\n    console.log(chalk.gray('// ' + message))\n  }\n}\n","import { injectable, inject } from 'inversify'\nimport { ICommandRegistry } from '@pixielity/ts-types'\nimport type { ICommandScheduler } from '@pixielity/ts-types'\nimport type { IScheduleExpression } from '@pixielity/ts-types'\nimport type { IScheduledTask } from '@pixielity/ts-types'\n\nimport { Output } from '../output/output'\n\n/**\n * Command scheduler class\n *\n * Schedules commands to run at specific intervals.\n */\n@injectable()\nexport class CommandScheduler implements ICommandScheduler {\n  /**\n   * The scheduled tasks\n   * @private\n   */\n  private tasks: IScheduledTask[] = []\n\n  /**\n   * The command registry\n   * @private\n   */\n  private commandRegistry: ICommandRegistry\n\n  /**\n   * The output instance\n   * @private\n   */\n  private output: Output\n\n  /**\n   * The timer ID for the scheduler\n   * @private\n   */\n  private timer?: NodeJS.Timeout\n\n  /**\n   * Creates a new CommandScheduler instance\n   *\n   * @param {ICommandRegistry} commandRegistry - The command registry\n   */\n  constructor(@inject(ICommandRegistry.$) commandRegistry: ICommandRegistry) {\n    this.commandRegistry = commandRegistry\n    this.output = new Output()\n  }\n\n  /**\n   * Schedules a command to run at a specific interval\n   *\n   * @param {string} commandName - The name of the command\n   * @param {IScheduleExpression} expression - The schedule expression\n   * @param {string[]} args - The arguments to pass to the command\n   * @param {Record<string, any>} options - The options to pass to the command\n   * @returns {CommandScheduler} The scheduler instance for chaining\n   */\n  public schedule(\n    commandName: string,\n    expression: IScheduleExpression,\n    args: string[] = [],\n    options: Record<string, any> = {},\n  ): CommandScheduler {\n    const command = this.commandRegistry.get(commandName)\n\n    if (!command) {\n      throw new Error(`Command \"${commandName}\" not found.`)\n    }\n\n    this.tasks.push({\n      command,\n      args,\n      options,\n      expression,\n      nextRun: this.calculateNextRun(expression),\n    })\n\n    return this\n  }\n\n  /**\n   * Starts the scheduler\n   *\n   * @param {number} interval - The interval in milliseconds to check for tasks to run\n   * @returns {CommandScheduler} The scheduler instance for chaining\n   */\n  public start(interval = 60000): CommandScheduler {\n    if (this.timer) {\n      clearInterval(this.timer)\n    }\n\n    this.timer = setInterval(() => this.tick(), interval)\n    this.output.info('Scheduler started.')\n\n    return this\n  }\n\n  /**\n   * Stops the scheduler\n   *\n   * @returns {CommandScheduler} The scheduler instance for chaining\n   */\n  public stop(): CommandScheduler {\n    if (this.timer) {\n      clearInterval(this.timer)\n      this.timer = undefined\n      this.output.info('Scheduler stopped.')\n    }\n\n    return this\n  }\n\n  /**\n   * Gets all scheduled tasks\n   *\n   * @returns {IScheduledTask[]} The scheduled tasks\n   */\n  public getTasks(): IScheduledTask[] {\n    return [...this.tasks]\n  }\n\n  /**\n   * Clears all scheduled tasks\n   *\n   * @returns {CommandScheduler} The scheduler instance for chaining\n   */\n  public clearTasks(): CommandScheduler {\n    this.tasks = []\n    return this\n  }\n\n  /**\n   * Runs a scheduled task\n   *\n   * @param {IScheduledTask} task - The task to run\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async runTask(task: IScheduledTask): Promise<void> {\n    try {\n      this.output.info(`Running scheduled command: ${task.command.getName()}`)\n\n      // Set output\n      task.command.setOutput(new Output())\n\n      // Set arguments and options\n      task.command.setArguments(task.args)\n      task.command.setOptions(task.options)\n\n      // Run before execute hook if it exists\n      if (task.command.beforeExecute) {\n        const shouldContinue = await task.command.beforeExecute()\n        if (!shouldContinue) {\n          this.output.warning(\n            `Command ${task.command.getName()} execution aborted by beforeExecute hook.`,\n          )\n          return\n        }\n      }\n\n      // Execute the command\n      const exitCode = await task.command.execute()\n\n      // Run after execute hook if it exists\n      if (task.command.afterExecute) {\n        await task.command.afterExecute(exitCode)\n      }\n\n      // Update last run time\n      task.lastRun = new Date()\n      // Calculate next run time\n      task.nextRun = this.calculateNextRun(task.expression)\n\n      this.output.success(`Command ${task.command.getName()} executed successfully.`)\n    } catch (error) {\n      this.output.error(\n        `Error running command ${task.command.getName()}: ${error instanceof Error ? error.message : String(error)}`,\n      )\n    }\n  }\n\n  /**\n   * Checks for tasks to run\n   *\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async tick(): Promise<void> {\n    const now = new Date()\n\n    for (const task of this.tasks) {\n      if (task.nextRun && task.nextRun <= now) {\n        await this.runTask(task)\n      }\n    }\n  }\n\n  /**\n   * Calculates the next run time for a schedule expression\n   *\n   * @param {IScheduleExpression} expression - The schedule expression\n   * @returns {Date} The next run time\n   * @private\n   */\n  private calculateNextRun(expression: IScheduleExpression): Date {\n    const now = new Date()\n    const next = new Date(now)\n\n    // Set to the next minute\n    next.setSeconds(0)\n    next.setMilliseconds(0)\n    next.setMinutes(next.getMinutes() + 1)\n\n    // Handle minute\n    if (expression.minute !== undefined && expression.minute !== '*') {\n      const minute = Number(expression.minute)\n      next.setMinutes(minute)\n      if (next <= now) {\n        next.setHours(next.getHours() + 1)\n      }\n    }\n\n    // Handle hour\n    if (expression.hour !== undefined && expression.hour !== '*') {\n      const hour = Number(expression.hour)\n      next.setHours(hour)\n      if (next <= now) {\n        next.setDate(next.getDate() + 1)\n      }\n    }\n\n    // Handle day of month\n    if (expression.dayOfMonth !== undefined && expression.dayOfMonth !== '*') {\n      const day = Number(expression.dayOfMonth)\n      next.setDate(day)\n      if (next <= now) {\n        next.setMonth(next.getMonth() + 1)\n      }\n    }\n\n    // Handle month\n    if (expression.month !== undefined && expression.month !== '*') {\n      const month = Number(expression.month) - 1 // JavaScript months are 0-based\n      next.setMonth(month)\n      if (next <= now) {\n        next.setFullYear(next.getFullYear() + 1)\n      }\n    }\n\n    // Handle day of week\n    if (expression.dayOfWeek !== undefined && expression.dayOfWeek !== '*') {\n      const dayOfWeek = Number(expression.dayOfWeek)\n      const currentDayOfWeek = next.getDay()\n      const daysToAdd = (dayOfWeek - currentDayOfWeek + 7) % 7\n      if (daysToAdd > 0) {\n        next.setDate(next.getDate() + daysToAdd)\n      } else if (next <= now) {\n        next.setDate(next.getDate() + 7)\n      }\n    }\n\n    return next\n  }\n}\n"]}