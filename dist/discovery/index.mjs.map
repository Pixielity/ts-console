{"version":3,"sources":["../../src/di/container.ts","../../src/decorators/command.decorator.ts","../../src/discovery/command-collector.ts"],"names":["ICommand","injectable"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,IAAM,SAAA,GAAY,IAAI,SAAU,CAAA;AAAA,EAC9B,YAAc,EAAA;AAChB,CAAC,CAAA;ACCM,IAAM,oBAAA,GAAuB,OAAO,SAAS,CAAA;;;ACM7C,IAAM,mBAAN,MAAoD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQzD,MAAa,gBAAA,CACX,SACA,EAAA,OAAA,GAAU,sBACW,EAAA;AACrB,IAAO,OAAA,gBAAA,CAAiB,gBAAiB,CAAA,SAAA,EAAW,OAAO,CAAA;AAAA;AAC7D;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,qBAAoC,GAAA;AACzC,IAAA,OAAO,iBAAiB,qBAAsB,EAAA;AAAA;AAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,mBAAmB,YAA6B,EAAA;AACrD,IAAO,OAAA,gBAAA,CAAiB,mBAAmB,YAAY,CAAA;AAAA;AACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,aAAoB,gBAAA,CAClB,SACA,EAAA,OAAA,GAAU,sBACW,EAAA;AACrB,IAAI,IAAA;AAEF,MAAM,MAAA,YAAA,GAAoB,gBAAW,SAAS,CAAA,GAC1C,YACK,IAAK,CAAA,IAAA,CAAA,OAAA,CAAQ,GAAI,EAAA,EAAG,SAAS,CAAA;AAGtC,MAAM,MAAA,KAAA,GAAQ,MAAM,IAAA,CAAK,OAAS,EAAA;AAAA,QAChC,GAAK,EAAA,YAAA;AAAA,QACL,QAAU,EAAA;AAAA,OACX,CAAA;AAGD,MAAA,KAAA,MAAW,QAAQ,KAAO,EAAA;AACxB,QAAI,IAAA;AAEF,UAAA,SAAA,CAAQ,IAAI,CAAA;AAAA,iBACL,KAAO,EAAA;AACd,UAAA,OAAA,CAAQ,KAAM,CAAA,CAAA,6BAAA,EAAgC,IAAI,CAAA,CAAA,CAAA,EAAK,KAAK,CAAA;AAAA;AAC9D;AAIF,MAAO,OAAA,SAAA,CAAU,MAAiBA,CAAAA,QAAAA,CAAS,CAAC,CAAA;AAAA,aACrC,KAAO,EAAA;AACd,MAAQ,OAAA,CAAA,KAAA,CAAM,+BAA+B,KAAK,CAAA;AAClD,MAAA,OAAO,EAAC;AAAA;AACV;AACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAc,qBAAoC,GAAA;AAChD,IAAO,OAAA,SAAA,CAAU,MAAiBA,CAAAA,QAAAA,CAAS,CAAC,CAAA;AAAA;AAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAc,mBAAmB,YAA6B,EAAA;AAC5D,IAAO,OAAA,OAAA,CAAQ,WAAY,CAAA,oBAAA,EAAsB,YAAY,CAAA;AAAA;AAEjE;AA7Fa,gBAAN,GAAA,eAAA,CAAA;AAAA,EADNC,UAAW;AAAA,CACC,EAAA,gBAAA,CAAA","file":"index.mjs","sourcesContent":["import { Container } from 'inversify'\nimport 'reflect-metadata'\n\n/**\n * The global Inversify container instance\n */\nconst container = new Container({\n  defaultScope: 'Singleton',\n})\n\nexport { container }\n","import 'reflect-metadata'\nimport { injectable } from 'inversify'\nimport { ICommand, ICommandOptions } from '@pixielity/ts-types'\n\nimport { container } from '../di/container'\n\n/**\n * Metadata key for command\n */\nexport const COMMAND_METADATA_KEY = Symbol('command')\n\n/**\n * Command decorator\n *\n * Marks a class as a console command and registers it with the container\n *\n * @param {CommandOptions} options - The command options\n * @returns {ClassDecorator} The class decorator\n */\nexport function Command(options: ICommandOptions): ClassDecorator {\n  return (target: Function): void => {\n    // Set default values for options\n    const commandOptions = {\n      ...options,\n      hidden: options.hidden ?? false,\n      injectable: options.injectable ?? true,\n      description: options.description || '',\n      shortcuts: options.shortcuts || [],\n    }\n\n    // Store command metadata with defaults applied\n    Reflect.defineMetadata(COMMAND_METADATA_KEY, commandOptions, target)\n\n    // Make the class injectable if not explicitly disabled\n    if (commandOptions.injectable) {\n      injectable()(target)\n\n      // Register the command with the container\n      // We use a multi-injection approach for commands\n      try {\n        container\n          .bind(ICommand.$)\n          .to(target as any)\n          .inSingletonScope()\n      } catch (error) {\n        // If the binding already exists, we can ignore the error\n        // This can happen during hot reloading\n      }\n    }\n  }\n}\n","import * as path from 'path'\nimport { glob } from 'glob'\nimport { injectable } from 'inversify'\nimport { ICommand } from '@pixielity/ts-types'\nimport type { ICommandCollector } from '@pixielity/ts-types'\n\nimport { container } from '../di/container'\nimport { COMMAND_METADATA_KEY } from '../decorators/command.decorator'\n\n/**\n * Command collector class\n *\n * Discovers and collects commands from the file system.\n */\n@injectable()\nexport class CommandCollector implements ICommandCollector {\n  /**\n   * Discovers commands in the specified directory\n   *\n   * @param {string} directory - The directory to scan for commands\n   * @param {string} pattern - The glob pattern to match command files\n   * @returns {Promise<ICommand[]>} The discovered commands\n   */\n  public async discoverCommands(\n    directory: string,\n    pattern = '**/*-command.{ts,js}',\n  ): Promise<ICommand[]> {\n    return CommandCollector.discoverCommands(directory, pattern)\n  }\n\n  /**\n   * Gets all commands that have been registered with the container\n   *\n   * @returns {ICommand[]} The registered commands\n   */\n  public getRegisteredCommands(): ICommand[] {\n    return CommandCollector.getRegisteredCommands()\n  }\n\n  /**\n   * Gets command metadata for a command class\n   *\n   * @param {Function} commandClass - The command class\n   * @returns {any} The command metadata\n   */\n  public getCommandMetadata(commandClass: Function): any {\n    return CommandCollector.getCommandMetadata(commandClass)\n  }\n\n  /**\n   * Discovers commands in the specified directory\n   *\n   * @param {string} directory - The directory to scan for commands\n   * @param {string} pattern - The glob pattern to match command files\n   * @returns {Promise<ICommand[]>} The discovered commands\n   */\n  public static async discoverCommands(\n    directory: string,\n    pattern = '**/*-command.{ts,js}',\n  ): Promise<ICommand[]> {\n    try {\n      // Get absolute path\n      const absolutePath = path.isAbsolute(directory)\n        ? directory\n        : path.join(process.cwd(), directory)\n\n      // Find all command files\n      const files = await glob(pattern, {\n        cwd: absolutePath,\n        absolute: true,\n      })\n\n      // Import each file\n      for (const file of files) {\n        try {\n          // Use require instead of dynamic import for TypeScript files\n          require(file)\n        } catch (error) {\n          console.error(`Error importing command file ${file}:`, error)\n        }\n      }\n\n      // Get all registered commands from the container\n      return container.getAll<ICommand>(ICommand.$)\n    } catch (error) {\n      console.error('Error discovering commands:', error)\n      return []\n    }\n  }\n\n  /**\n   * Gets all commands that have been registered with the container\n   *\n   * @returns {ICommand[]} The registered commands\n   */\n  public static getRegisteredCommands(): ICommand[] {\n    return container.getAll<ICommand>(ICommand.$)\n  }\n\n  /**\n   * Gets command metadata for a command class\n   *\n   * @param {Function} commandClass - The command class\n   * @returns {any} The command metadata\n   */\n  public static getCommandMetadata(commandClass: Function): any {\n    return Reflect.getMetadata(COMMAND_METADATA_KEY, commandClass)\n  }\n}\n"]}