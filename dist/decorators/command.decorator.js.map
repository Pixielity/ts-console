{"version":3,"sources":["../../src/di/container.ts","../../src/decorators/command.decorator.ts"],"names":["Container","injectable","ICommand"],"mappings":";;;;;;;;;;;;;;;AAMA,IAAM,SAAA,GAAY,IAAIA,mBAAU,CAAA;AAAA,EAC9B,YAAc,EAAA;AAChB,CAAC,CAAA;;;ACCY,IAAA,oBAAA,GAAuB,OAAO,SAAS;AAU7C,SAAS,QAAQ,OAA0C,EAAA;AAChE,EAAA,OAAO,CAAC,MAA2B,KAAA;AApBrC,IAAA,IAAA,EAAA,EAAA,EAAA;AAsBI,IAAA,MAAM,cAAiB,GAAA;AAAA,MACrB,GAAG,OAAA;AAAA,MACH,MAAA,EAAA,CAAQ,EAAQ,GAAA,OAAA,CAAA,MAAA,KAAR,IAAkB,GAAA,EAAA,GAAA,KAAA;AAAA,MAC1B,UAAA,EAAA,CAAY,EAAQ,GAAA,OAAA,CAAA,UAAA,KAAR,IAAsB,GAAA,EAAA,GAAA,IAAA;AAAA,MAClC,WAAA,EAAa,QAAQ,WAAe,IAAA,EAAA;AAAA,MACpC,SAAA,EAAW,OAAQ,CAAA,SAAA,IAAa;AAAC,KACnC;AAGA,IAAQ,OAAA,CAAA,cAAA,CAAe,oBAAsB,EAAA,cAAA,EAAgB,MAAM,CAAA;AAGnE,IAAA,IAAI,eAAe,UAAY,EAAA;AAC7B,MAAAC,oBAAA,GAAa,MAAM,CAAA;AAInB,MAAI,IAAA;AACF,QAAA,SAAA,CACG,KAAKC,gBAAS,CAAA,CAAC,EACf,EAAG,CAAA,MAAa,EAChB,gBAAiB,EAAA;AAAA,eACb,KAAO,EAAA;AAAA;AAGhB;AACF,GACF;AACF","file":"command.decorator.js","sourcesContent":["import { Container } from \"inversify\"\nimport \"reflect-metadata\"\n\n/**\n * The global Inversify container instance\n */\nconst container = new Container({\n  defaultScope: \"Singleton\",\n})\n\nexport { container }\n","import 'reflect-metadata'\nimport { injectable } from 'inversify'\nimport { ICommand, ICommandOptions } from '@pixielity/ts-types'\n\nimport { container } from '../di/container'\n\n/**\n * Metadata key for command\n */\nexport const COMMAND_METADATA_KEY = Symbol('command')\n\n/**\n * Command decorator\n *\n * Marks a class as a console command and registers it with the container\n *\n * @param {CommandOptions} options - The command options\n * @returns {ClassDecorator} The class decorator\n */\nexport function Command(options: ICommandOptions): ClassDecorator {\n  return (target: Function): void => {\n    // Set default values for options\n    const commandOptions = {\n      ...options,\n      hidden: options.hidden ?? false,\n      injectable: options.injectable ?? true,\n      description: options.description || '',\n      shortcuts: options.shortcuts || [],\n    }\n\n    // Store command metadata with defaults applied\n    Reflect.defineMetadata(COMMAND_METADATA_KEY, commandOptions, target)\n\n    // Make the class injectable if not explicitly disabled\n    if (commandOptions.injectable) {\n      injectable()(target)\n\n      // Register the command with the container\n      // We use a multi-injection approach for commands\n      try {\n        container\n          .bind(ICommand.$)\n          .to(target as any)\n          .inSingletonScope()\n      } catch (error) {\n        // If the binding already exists, we can ignore the error\n        // This can happen during hot reloading\n      }\n    }\n  }\n}\n"]}