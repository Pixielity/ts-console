{"version":3,"sources":["../../src/decorators/argument.decorator.ts","../../src/di/container.ts","../../src/decorators/command.decorator.ts","../../src/decorators/option.decorator.ts"],"names":["Container","injectable","ICommand"],"mappings":";;;;;;;;;;;;;;;AAKa,IAAA,qBAAA,GAAwB,OAAO,UAAU;AAwC/C,SAAS,SAAS,OAA6C,EAAA;AACpE,EAAO,OAAA,CAAC,QAAgB,WAAiC,KAAA;AAIvD,IAAA,IAAI,OAAO,OAAQ,CAAA,IAAA;AACnB,IAAI,IAAA,CAAC,QAAQ,QAAU,EAAA;AACrB,MAAA,IAAA,GAAO,IAAI,IAAI,CAAA,CAAA,CAAA;AAAA,KACV,MAAA;AACL,MAAA,IAAA,GAAO,IAAI,IAAI,CAAA,CAAA,CAAA;AAAA;AAGjB,IAAA,IAAI,QAAQ,OAAS,EAAA;AACnB,MAAA,IAAA,GAAO,GAAG,IAAI,CAAA,GAAA,CAAA;AAAA;AAGhB,IAAA,MAAM,QAAW,GAAA;AAAA,MACf,IAAA;AAAA,MACA,WAAA,EAAa,QAAQ,WAAe,IAAA,EAAA;AAAA,MACpC,cAAc,OAAQ,CAAA,YAAA;AAAA,MACtB;AAAA,KACF;AAGA,IAAA,MAAM,mBAAmB,OAAQ,CAAA,WAAA,CAAY,uBAAuB,MAAO,CAAA,WAAW,KAAK,EAAC;AAG5F,IAAA,gBAAA,CAAiB,KAAK,QAAQ,CAAA;AAG9B,IAAA,OAAA,CAAQ,cAAe,CAAA,qBAAA,EAAuB,gBAAkB,EAAA,MAAA,CAAO,WAAW,CAAA;AAAA,GACpF;AACF;ACvEA,IAAM,SAAA,GAAY,IAAIA,mBAAU,CAAA;AAAA,EAC9B,YAAc,EAAA;AAChB,CAAC,CAAA;;;ACCY,IAAA,oBAAA,GAAuB,OAAO,SAAS;AAU7C,SAAS,QAAQ,OAA0C,EAAA;AAChE,EAAA,OAAO,CAAC,MAA2B,KAAA;AApBrC,IAAA,IAAA,EAAA,EAAA,EAAA;AAsBI,IAAA,MAAM,cAAiB,GAAA;AAAA,MACrB,GAAG,OAAA;AAAA,MACH,MAAA,EAAA,CAAQ,EAAQ,GAAA,OAAA,CAAA,MAAA,KAAR,IAAkB,GAAA,EAAA,GAAA,KAAA;AAAA,MAC1B,UAAA,EAAA,CAAY,EAAQ,GAAA,OAAA,CAAA,UAAA,KAAR,IAAsB,GAAA,EAAA,GAAA,IAAA;AAAA,MAClC,WAAA,EAAa,QAAQ,WAAe,IAAA,EAAA;AAAA,MACpC,SAAA,EAAW,OAAQ,CAAA,SAAA,IAAa;AAAC,KACnC;AAGA,IAAQ,OAAA,CAAA,cAAA,CAAe,oBAAsB,EAAA,cAAA,EAAgB,MAAM,CAAA;AAGnE,IAAA,IAAI,eAAe,UAAY,EAAA;AAC7B,MAAAC,oBAAA,GAAa,MAAM,CAAA;AAInB,MAAI,IAAA;AACF,QAAA,SAAA,CACG,KAAKC,gBAAS,CAAA,CAAC,EACf,EAAG,CAAA,MAAa,EAChB,gBAAiB,EAAA;AAAA,eACb,KAAO,EAAA;AAAA;AAGhB;AACF,GACF;AACF;AC7Ca,IAAA,mBAAA,GAAsB,OAAO,QAAQ;AA8B3C,SAAS,OAAO,OAA2C,EAAA;AAChE,EAAO,OAAA,CAAC,QAAgB,WAAiC,KAAA;AACvD,IAAA,MAAM,QAAW,GAAA;AAAA,MACf,OAAO,OAAQ,CAAA,KAAA;AAAA,MACf,WAAA,EAAa,QAAQ,WAAe,IAAA,EAAA;AAAA,MACpC,cAAc,OAAQ,CAAA,YAAA;AAAA,MACtB;AAAA,KACF;AAGA,IAAA,MAAM,mBAAmB,OAAQ,CAAA,WAAA,CAAY,qBAAqB,MAAO,CAAA,WAAW,KAAK,EAAC;AAG1F,IAAA,gBAAA,CAAiB,KAAK,QAAQ,CAAA;AAG9B,IAAA,OAAA,CAAQ,cAAe,CAAA,mBAAA,EAAqB,gBAAkB,EAAA,MAAA,CAAO,WAAW,CAAA;AAAA,GAClF;AACF","file":"index.js","sourcesContent":["import 'reflect-metadata'\n\n/**\n * Metadata key for arguments\n */\nexport const ARGUMENT_METADATA_KEY = Symbol('argument')\n\n/**\n * Argument options interface\n */\nexport interface ArgumentOptions {\n  /**\n   * The name of the argument\n   */\n  name: string\n\n  /**\n   * The description of the argument\n   */\n  description?: string\n\n  /**\n   * The default value of the argument\n   */\n  defaultValue?: any\n\n  /**\n   * Whether the argument is required\n   */\n  required?: boolean\n\n  /**\n   * Whether the argument is an array (variadic)\n   */\n  isArray?: boolean\n}\n\n/**\n * Argument decorator\n *\n * Defines a command argument\n *\n * @param {ArgumentOptions} options - The argument options\n * @returns {PropertyDecorator} The property decorator\n */\nexport function Argument(options: ArgumentOptions): PropertyDecorator {\n  return (target: Object, propertyKey: string | symbol) => {\n    // Format the argument name for Commander\n    // If it's required, don't add brackets\n    // If it's an array, add ellipsis\n    let name = options.name\n    if (!options.required) {\n      name = `[${name}]`\n    } else {\n      name = `<${name}>`\n    }\n\n    if (options.isArray) {\n      name = `${name}...`\n    }\n\n    const metadata = {\n      name,\n      description: options.description || '',\n      defaultValue: options.defaultValue,\n      propertyKey,\n    }\n\n    // Get existing metadata or initialize empty array\n    const existingMetadata = Reflect.getMetadata(ARGUMENT_METADATA_KEY, target.constructor) || []\n\n    // Add new metadata\n    existingMetadata.push(metadata)\n\n    // Update metadata\n    Reflect.defineMetadata(ARGUMENT_METADATA_KEY, existingMetadata, target.constructor)\n  }\n}\n","import { Container } from 'inversify'\nimport 'reflect-metadata'\n\n/**\n * The global Inversify container instance\n */\nconst container = new Container({\n  defaultScope: 'Singleton',\n})\n\nexport { container }\n","import 'reflect-metadata'\nimport { injectable } from 'inversify'\nimport { ICommand, ICommandOptions } from '@pixielity/ts-types'\n\nimport { container } from '../di/container'\n\n/**\n * Metadata key for command\n */\nexport const COMMAND_METADATA_KEY = Symbol('command')\n\n/**\n * Command decorator\n *\n * Marks a class as a console command and registers it with the container\n *\n * @param {CommandOptions} options - The command options\n * @returns {ClassDecorator} The class decorator\n */\nexport function Command(options: ICommandOptions): ClassDecorator {\n  return (target: Function): void => {\n    // Set default values for options\n    const commandOptions = {\n      ...options,\n      hidden: options.hidden ?? false,\n      injectable: options.injectable ?? true,\n      description: options.description || '',\n      shortcuts: options.shortcuts || [],\n    }\n\n    // Store command metadata with defaults applied\n    Reflect.defineMetadata(COMMAND_METADATA_KEY, commandOptions, target)\n\n    // Make the class injectable if not explicitly disabled\n    if (commandOptions.injectable) {\n      injectable()(target)\n\n      // Register the command with the container\n      // We use a multi-injection approach for commands\n      try {\n        container\n          .bind(ICommand.$)\n          .to(target as any)\n          .inSingletonScope()\n      } catch (error) {\n        // If the binding already exists, we can ignore the error\n        // This can happen during hot reloading\n      }\n    }\n  }\n}\n","import 'reflect-metadata'\n\n/**\n * Metadata key for options\n */\nexport const OPTION_METADATA_KEY = Symbol('option')\n\n/**\n * Option options interface\n */\nexport interface OptionOptions {\n  /**\n   * The flags for the option (e.g., \"-n, --name\")\n   */\n  flags: string\n\n  /**\n   * The description of the option\n   */\n  description?: string\n\n  /**\n   * The default value of the option\n   */\n  defaultValue?: any\n}\n\n/**\n * Option decorator\n *\n * Defines a command option\n *\n * @param {OptionOptions} options - The option options\n * @returns {PropertyDecorator} The property decorator\n */\nexport function Option(options: OptionOptions): PropertyDecorator {\n  return (target: Object, propertyKey: string | symbol) => {\n    const metadata = {\n      flags: options.flags,\n      description: options.description || '',\n      defaultValue: options.defaultValue,\n      propertyKey,\n    }\n\n    // Get existing metadata or initialize empty array\n    const existingMetadata = Reflect.getMetadata(OPTION_METADATA_KEY, target.constructor) || []\n\n    // Add new metadata\n    existingMetadata.push(metadata)\n\n    // Update metadata\n    Reflect.defineMetadata(OPTION_METADATA_KEY, existingMetadata, target.constructor)\n  }\n}\n"]}